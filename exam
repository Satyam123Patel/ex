package Stack;

public class Queue1 {

    // Queue variables (NOT static)
    String[] queue;
    int front, rear, capacity;

    // Constructor
    Queue1(int size) {
        capacity = size;
        queue = new String[capacity];
        front = 0;
        rear = -1;
    }

    // Enqueue
    void enqueue(String value) {
        if (rear == capacity - 1) {
            return;
        }
        queue[++rear] = value;
    }

    // Dequeue
    String dequeue() {
        if (front > rear) {
            return null;
        }
        return queue[front++];
    }

    // Generate binary numbers
    static void generateBinary(int n) {
        Queue1 q = new Queue1(2 * n);

        q.enqueue("1");

        for (int i = 1; i <= n; i++) {
            String current = q.dequeue();
            System.out.print(current + " ");

            q.enqueue(current + "0");
            q.enqueue(current + "1");
        }
    }

    public static void main(String[] args) {
        int n = 5;
        generateBinary(n);
    }
}




import java.util.Scanner;

public class CircularQueue {

    int[] arr;
    int front, rear, size, count;

    CircularQueue(int n) {
        size = n;
        arr = new int[size];
        front = 0;
        rear = -1;
        count = 0;
    }

    void enqueue(int value) {
        if (count == size) {
            return; // Queue Overflow
        }
        rear = (rear + 1) % size;
        arr[rear] = value;
        count++;
    }

    void dequeue() {
        if (count == 0) {
            return; // Queue Underflow
        }
        front = (front + 1) % size;
        count--;
    }

    
    void display() {
        if (count == 0) {
            return;
        }
        int i = front;
        for (int c = 0; c < count; c++) {
            System.out.print(arr[i] + " ");
            i = (i + 1) % size;
        }
        System.out.println();
    }

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        // Read size of queue
        int n = sc.nextInt();
        sc.nextLine(); // consume newline

        CircularQueue queue = new CircularQueue(n);

        while (true) {
            String command = sc.nextLine();

            if (command.equals("STOP")) {
                break;
            } 
            else if (command.startsWith("ENQUEUE")) {
                int value = Integer.parseInt(command.split(" ")[1]);
                queue.enqueue(value);
            } 
            else if (command.equals("DEQUEUE")) {
                queue.dequeue();
            } 
            else if (command.equals("DISPLAY")) {
                queue.display();
            }
        }

        sc.close();
    }
}





package ArrayQueueBinaryNo;

import java.util.Scanner;

public class Postfixex {

    int[] arr;
    int top;
    int capacity;

    Postfixex(int size) {
        capacity = size;
        arr = new int[size];
        top = -1;
    }

    void push(int value) {
        if (top == capacity - 1) return;
        arr[++top] = value;
    }

    int pop() {
        if (top == -1) return -1;
        return arr[top--];
    }

    static int Postfixexp(String expression) {

        String[] tokens = expression.split(" ");
        Postfixex stack = new Postfixex(tokens.length);

        for (String token : tokens) {

            if (Character.isDigit(token.charAt(0))) {
                stack.push(Integer.parseInt(token));
            } else {
                int b = stack.pop();
                int a = stack.pop();

                switch (token) {
                    case "+":
                        stack.push(a + b);
                        break;
                    case "-":
                        stack.push(a - b);
                        break;
                    case "*":
                        stack.push(a * b);
                        break;
                    case "/":
                        stack.push(a / b);
                        break;
                }
            }
        }
        return stack.pop();
    }

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        String postfix = sc.nextLine();

        int result = Postfixexp(postfix);
        System.out.println(result);

        sc.close();
    }
}




import java.util.Scanner;

public class BalancedParentheses {

    // Stack using array
    static class Stack {
        char[] arr;
        int top;
        int capacity;

        Stack(int size) {
            capacity = size;
            arr = new char[capacity];
            top = -1;
        }

        // Push with overflow check
        void push(char ch) {
            if (top == capacity - 1) {
                return; // Stack Overflow
            }
            arr[++top] = ch;
        }

        // Pop with underflow check
        char pop() {
            if (top == -1) {
                return '\0'; // Stack Underflow
            }
            return arr[top--];
        }

        boolean isEmpty() {
            return top == -1;
        }
    }

    static boolean isBalanced(String expr) {

        Stack stack = new Stack(expr.length());

        for (int i = 0; i < expr.length(); i++) {
            char ch = expr.charAt(i);

            // Opening brackets
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            }
            // Closing brackets
            else if (ch == ')' || ch == '}' || ch == ']') {

                if (stack.isEmpty()) {
                    return false;
                }

                char top = stack.pop();

                if ((ch == ')' && top != '(') ||
                    (ch == '}' && top != '{') ||
                    (ch == ']' && top != '[')) {
                    return false;
                }
            }
        }
        return stack.isEmpty();
    }

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        String expression = sc.nextLine();

        if (isBalanced(expression)) {
            System.out.println("Balanced");
        } else {
            System.out.println("Not Balanced");
        }

        sc.close();
    }
}




public class StackArray {

    int[] arr;
    int top;
    int size;

    StackArray(int n) {
        size = n;
        arr = new int[size];
        top = -1;
    }

    void push(int value) {
        if (top == size - 1) {
            System.out.println("Stack Overflow");
            return;
        }
        arr[++top] = value;
    }

    int pop() {
        if (top == -1) {
            System.out.println("Stack Underflow");
            return -1;
        }
        return arr[top--];
    }

    int peek() {
        if (top == -1) return -1;
        return arr[top];
    }

    boolean isEmpty() {
        return top == -1;
    }

    public static void main(String[] args) {
        StackArray s = new StackArray(5);
        s.push(10);
        s.push(20);
        System.out.println(s.pop());
        System.out.println(s.peek());
        System.out.println(s.isEmpty());
    }
}



public class QueueArray {

    int[] arr;
    int front, rear, size;

    QueueArray(int n) {
        size = n;
        arr = new int[size];
        front = 0;
        rear = -1;
    }

    void enqueue(int value) {
        if (rear == size - 1) {
            System.out.println("Queue Overflow");
            return;
        }
        arr[++rear] = value;
    }

    int dequeue() {
        if (front > rear) {
            System.out.println("Queue Underflow");
            return -1;
        }
        return arr[front++];
    }

    void display() {
        for (int i = front; i <= rear; i++) {
            System.out.print(arr[i] + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        QueueArray q = new QueueArray(5);
        q.enqueue(1);
        q.enqueue(2);
        q.enqueue(3);
        q.display();
        q.dequeue();
        q.display();
    }
}


public class ReverseString {

    static String reverse(String str) {
        char[] stack = new char[str.length()];
        int top = -1;

        for (int i = 0; i < str.length(); i++) {
            stack[++top] = str.charAt(i);
        }

        String result = "";
        while (top != -1) {
            result += stack[top--];
        }
        return result;
    }

    public static void main(String[] args) {
        String input = "HELLO";
        System.out.println(reverse(input));
    }
}



public class ReverseArray {

    static void reverse(int[] arr) {
        int[] stack = new int[arr.length];
        int top = -1;

        for (int i = 0; i < arr.length; i++) {
            stack[++top] = arr[i];
        }

        for (int i = 0; i < arr.length; i++) {
            arr[i] = stack[top--];
        }
    }

    public static void main(String[] args) {
        int[] arr = {1, 2, 3};
        reverse(arr);

        for (int x : arr) {
            System.out.print(x + " ");
        }
    }
}



public class PalindromeCheck {

    static boolean isPalindrome(String str) {
        char[] stack = new char[str.length()];
        int top = -1;

        for (int i = 0; i < str.length(); i++) {
            stack[++top] = str.charAt(i);
        }

        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) != stack[top--]) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        String input = "MADAM";

        if (isPalindrome(input)) {
            System.out.println("Palindrome");
        } else {
            System.out.println("Not Palindrome");
        }
    }
}



